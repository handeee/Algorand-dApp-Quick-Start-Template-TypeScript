{"version":3,"file":"index.mjs","sources":["../src/primitives.ts","../src/util.ts","../src/reference.ts","../src/box.ts","../src/state.ts","../src/transactions.ts","../src/logic-sig.ts","../src/template-var.ts","../src/compiled.ts","../src/mutable-array.ts","../src/arc-28.ts","../src/on-complete-action.ts"],"sourcesContent":["import { NoImplementation } from './internal/errors'\n\n/**\n * An alias for types which can be converted to a uint64\n */\nexport type Uint64Compat = uint64 | bigint | boolean | number\n/**\n * An alias for types which can be converted to a biguint\n */\nexport type BigUintCompat = bigint | bytes | number | boolean\n/**\n * An alias for types which can be converted to a string\n */\nexport type StringCompat = string\n/**\n * An alias for types which can be converted to a bytes sequence\n */\nexport type BytesCompat = bytes | string\n\n/**\n * An unsigned integer of exactly 64 bits\n */\nexport type uint64 = {\n  /**\n   * @hidden\n   */\n  __type?: 'uint64'\n} & number\n\n/**\n * Create a uint64 with the default value of 0\n */\nexport function Uint64(): uint64\n/**\n * Create a uint64 from a string literal\n */\nexport function Uint64(v: string): uint64\n/**\n * Create a uint64 from a bigint literal\n */\nexport function Uint64(v: bigint): uint64\n/**\n * Create a uint64 from a number literal\n */\nexport function Uint64(v: number): uint64\n/**\n * Create a uint64 from a boolean value. True is 1, False is 0\n */\nexport function Uint64(v: boolean): uint64\nexport function Uint64(v?: Uint64Compat | string): uint64 {\n  throw new NoImplementation()\n}\n\n/**\n * An unsigned integer of up to 512 bits\n *\n * Stored as a big-endian variable byte array\n */\nexport type biguint = {\n  /**\n   * @hidden\n   */\n  __type?: 'biguint'\n} & bigint\n\n/**\n * Create a biguint from a bigint literal\n */\nexport function BigUint(v: bigint): biguint\n/**\n * Create a biguint from a boolean value (true = 1, false = 0)\n */\nexport function BigUint(v: boolean): biguint\n/**\n * Create a biguint from a uint64 value\n */\nexport function BigUint(v: uint64): biguint\n/**\n * Create a biguint from a number literal\n */\nexport function BigUint(v: number): biguint\n/**\n * Create a biguint from a byte array interpreted as a big-endian number\n */\nexport function BigUint(v: bytes): biguint\n/**\n * Create a biguint from a string literal containing the decimal digits\n */\nexport function BigUint(v: string): biguint\n/**\n * Create a biguint with the default value of 0\n */\nexport function BigUint(): biguint\nexport function BigUint(v?: BigUintCompat | string): biguint {\n  throw new NoImplementation()\n}\n\n/**\n * A sequence of zero or more bytes (ie. byte[])\n */\nexport type bytes = {\n  /**\n   * Retrieve the length of the byte sequence\n   */\n  readonly length: uint64\n\n  /**\n   * Retrieve the byte at the index i\n   * @param i The index to read. Can be negative to read from the end\n   * @returns The byte found at the index, or an empty bytes value\n   */\n  at(i: Uint64Compat): bytes\n\n  /**\n   * Concatenate this bytes value with another bytes value\n   * @param other The other bytes value\n   * @returns The concatenation result\n   */\n  concat(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise AND operation with this bytes value and another bytes value.\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseAnd(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise OR operation with this bytes value and another bytes value\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseOr(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise XOR operation with this bytes value and another bytes value.\n   *\n   * The shorter of the two values will be zero-left extended to the larger length.\n   * @param other The other bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseXor(other: BytesCompat): bytes\n\n  /**\n   * Perform a bitwise INVERT operation with this bytes value\n   * @returns The bitwise operation result\n   */\n  bitwiseInvert(): bytes\n\n  /**\n   * Compares this bytes value with another.\n   * @param other The other bytes value\n   * @returns True if both values represent the same byte sequence\n   */\n  equals(other: BytesCompat): boolean\n\n  /**\n   * Returns a copy of this bytes sequence\n   */\n  slice(): bytes\n  /**\n   * Returns a slice of this bytes sequence from the specified start to the end\n   * @param start The index to start slicing from. Can be negative to count from the end.\n   */\n  slice(start: Uint64Compat): bytes\n  /**\n   * Returns a slice of this bytes sequence from the specified start to the specified end\n   * @param start The index to start slicing from. Can be negative to count from the end.\n   * @param end The index to end the slice. Can be negative to count from the end.\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): bytes\n  /**\n   * @hidden\n   */\n  slice(start?: Uint64Compat, end?: Uint64Compat): bytes\n\n  /**\n   * Interpret this byte sequence as a utf-8 string\n   */\n  toString(): string\n}\n\n/**\n * Create a byte array from a string interpolation template and compatible replacements\n * @param value\n * @param replacements\n */\nexport function Bytes(value: TemplateStringsArray, ...replacements: BytesCompat[]): bytes\n/**\n * Create a byte array from a utf8 string\n */\nexport function Bytes(value: string): bytes\n/**\n * No op, returns the provided byte array.\n */\nexport function Bytes(value: bytes): bytes\n/**\n * Create a byte array from a biguint value encoded as a variable length big-endian number\n */\nexport function Bytes(value: biguint): bytes\n/**\n * Create a byte array from a uint64 value encoded as a fixed length 64-bit number\n */\nexport function Bytes(value: uint64): bytes\n/**\n * Create a byte array from an Iterable<uint64> where each item is interpreted as a single byte and must be between 0 and 255 inclusively\n */\nexport function Bytes(value: Iterable<uint64>): bytes\n/**\n * Create an empty byte array\n */\nexport function Bytes(): bytes\nexport function Bytes(\n  value?: BytesCompat | TemplateStringsArray | biguint | uint64 | Iterable<number>,\n  ...replacements: BytesCompat[]\n): bytes {\n  throw new NoImplementation()\n}\n\n/**\n * Create a new bytes value from a hexadecimal encoded string\n * @param hex A literal string of hexadecimal characters\n */\nBytes.fromHex = (hex: string): bytes => {\n  throw new NoImplementation()\n}\n/**\n * Create a new bytes value from a base 64 encoded string\n * @param b64 A literal string of b64 encoded characters\n */\nBytes.fromBase64 = (b64: string): bytes => {\n  throw new NoImplementation()\n}\n\n/**\n * Create a new bytes value from a base 32 encoded string\n * @param b32 A literal string of b32 encoded characters\n */\nBytes.fromBase32 = (b32: string): bytes => {\n  throw new NoImplementation()\n}\n\n/**\n * An interface for types which are backed by the AVM bytes type\n */\nexport interface BytesBacked {\n  /**\n   * Retrieve the underlying bytes representing this value\n   */\n  get bytes(): bytes\n}\n\n/**\n * Declare a homogeneous tuple with the item type T and length N.\n *\n * Eg.\n * NTuple<uint64, 3> === [uint64, uint64, uint64]\n */\nexport type NTuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, readonly []>) : never\n\ntype _TupleOf<T, N extends number, R extends readonly unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, readonly [T, ...R]>\n","import { NoImplementation } from './internal/errors'\nimport { biguint, BigUintCompat, BytesBacked, BytesCompat, StringCompat, uint64, Uint64Compat } from './primitives'\n\n/**\n * Write one or more values to the transaction log.\n *\n * Each value is converted to bytes and concatenated\n * @param args The values to write\n */\nexport function log(...args: Array<Uint64Compat | BytesCompat | BigUintCompat | StringCompat | BytesBacked>): void {\n  throw new NoImplementation()\n}\n\n/**\n * Asserts that `condition` is truthy, otherwise error and halt execution.\n * @param condition An expression that can be evaluated as truthy of falsy\n * @param message The message to show if `condition` is falsy and an error is raised.\n */\nexport function assert(condition: unknown, message?: string): asserts condition {\n  throw new NoImplementation()\n}\n\n/**\n * Raise an error and halt execution\n * @param message The message to accompany the error\n */\nexport function err(message?: string): never {\n  throw new NoImplementation()\n}\n\n/**\n * Defines possible comparison expressions for numeric types\n */\ntype NumericComparison<T> =\n  | T\n  | {\n      /**\n       * Is the subject less than the specified value\n       */\n      lessThan: T\n    }\n  | {\n      /**\n       * Is the subject greater than the specified value\n       */\n      greaterThan: T\n    }\n  | {\n      /**\n       * Is the subject greater than or equal to the specified value\n       */\n      greaterThanEq: T\n    }\n  | {\n      /**\n       * Is the subject less than or equal to the specified value\n       */\n      lessThanEq: T\n    }\n  | {\n      /**\n       * Is the subject between the specified values (inclusive)\n       */\n      between: [T, T]\n    }\n\n/**\n * Returns compatible comparison expressions for a type `T`\n * @typeParam T The type requiring comparison\n */\ntype ComparisonFor<T> = T extends uint64 | biguint ? NumericComparison<T> : T\n\n/**\n * A set of tests to apply to the match subject\n * @typeParam T The type of the test subject\n */\ntype MatchTest<T> = {\n  [key in keyof T]?: ComparisonFor<T[key]>\n}\n\n/**\n * Applies all tests in `test` against `subject` and returns a boolean indicating if they all pass\n * @param subject An object or tuple to be tested\n * @param test An object containing one or more tests to be applied to the subject\n * @typeParam T The type of the subject\n * @returns True if all tests pass, otherwise false\n */\nexport function match<T>(subject: T, test: MatchTest<T>): boolean {\n  throw new NoImplementation()\n}\n\n/**\n *\n * Applies all tests in `test` against `subject` and asserts they all pass\n * @param subject An object or tuple to be tested\n * @param test An object containing one or more tests to be applied to the subject\n * @param message An optional message to show if the assertion fails\n * @typeParam T The type of the subject\n */\nexport function assertMatch<T>(subject: T, test: MatchTest<T>, message?: string): boolean {\n  throw new NoImplementation()\n}\n\n/**\n * Defines the source of fees for the OpUp utility\n */\nexport enum OpUpFeeSource {\n  /**\n   * Only the excess fee (credit) on the outer group should be used (itxn.fee = 0)\n   */\n  GroupCredit = 0,\n  /**\n   * The app's account will cover all fees (itxn.fee = Global.minTxFee)\n   */\n  AppAccount = 1,\n  /**\n   * First the excess will be used, then remaining fees taken from the app account\n   */\n  Any = 2,\n}\n\n/**\n * Ensure the available op code budget is greater than or equal to requiredBudget.\n *\n * This is done by adding AppCall itxns to the group to increase the available budget. These itxns must be paid for\n * by the caller or the application.\n * @param requiredBudget The total required budget\n * @param feeSource Which source to withdraw txn fees from.\n */\nexport function ensureBudget(requiredBudget: uint64, feeSource: OpUpFeeSource = OpUpFeeSource.GroupCredit) {\n  throw new NoImplementation()\n}\n\n/**\n * Generates an iterable sequence from 0...stop inclusive\n * @param stop The stop number of the sequence\n */\nexport function urange(stop: Uint64Compat): IterableIterator<uint64>\n/**\n * Generates an iterable sequence from start...stop inclusive\n * @param start The start number of the sequence\n * @param stop The stop number of the sequence\n */\nexport function urange(start: Uint64Compat, stop: Uint64Compat): IterableIterator<uint64>\n/**\n * Generates an iterable sequence from start...stop inclusive with increments of size step\n * @param start The start number of the sequence\n * @param stop The stop number of the sequence\n * @param step The step size of the sequence\n */\nexport function urange(start: Uint64Compat, stop: Uint64Compat, step: Uint64Compat): IterableIterator<uint64>\nexport function urange(a: Uint64Compat, b?: Uint64Compat, c?: Uint64Compat): IterableIterator<uint64> {\n  throw new NoImplementation()\n}\n\n/**\n * Defines a numeric range including all numbers between from and to\n */\nexport type NumberRange = { from: number; to: number }\n","import { NoImplementation } from './internal/errors'\nimport { bytes, uint64 } from './primitives'\n\n/**\n * Represents an Algorand Account and exposes properties and methods for reading account data\n */\nexport type Account = {\n  /**\n   * Get the accounts address in bytes\n   */\n  readonly bytes: bytes\n\n  /**\n   * Account balance in microalgos\n   *\n   * Account must be an available resource\n   */\n  readonly balance: uint64\n\n  /**\n   * Minimum required balance for account, in microalgos\n   *\n   * Account must be an available resource\n   */\n  readonly minBalance: uint64\n\n  /**\n   * Address the account is rekeyed to\n   *\n   * Account must be an available resource\n   */\n  readonly authAddress: Account\n\n  /**\n   * The total number of uint64 values allocated by this account in Global and Local States.\n   *\n   * Account must be an available resource\n   */\n  readonly totalNumUint: uint64\n\n  /**\n   * The total number of byte array values allocated by this account in Global and Local States.\n   *\n   * Account must be an available resource\n   */\n  readonly totalNumByteSlice: uint64\n\n  /**\n   * The number of extra app code pages used by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalExtraAppPages: uint64\n\n  /**\n   * The number of existing apps created by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAppsCreated: uint64\n\n  /**\n   * The number of apps this account is opted into.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAppsOptedIn: uint64\n\n  /**\n   * The number of existing ASAs created by this account.\n   *\n   * Account must be an available resource\n   */\n  readonly totalAssetsCreated: uint64\n\n  /**\n   * The numbers of ASAs held by this account (including ASAs this account created).\n   *\n   * Account must be an available resource\n   */\n  readonly totalAssets: uint64\n\n  /**\n   * The number of existing boxes created by this account's app.\n   *\n   * Account must be an available resource\n   */\n  readonly totalBoxes: uint64\n\n  /**\n   * The total number of bytes used by this account's app's box keys and values.\n   *\n   * Account must be an available resource\n   */\n  readonly totalBoxBytes: uint64\n\n  /**\n   * Returns true if this account is opted in to the specified Asset or Application.\n   * Note: Account and Asset/Application must be an available resource\n   *\n   * @param assetOrApp\n   */\n  isOptedIn(assetOrApp: Asset | Application): boolean\n}\n\n/**\n * Create a new account object representing the zero address\n */\nexport function Account(): Account\n/**\n * Create a new account object representing the provided public key bytes\n * @param publicKey A 32-byte Algorand account public key\n */\nexport function Account(publicKey: bytes): Account\n/**\n * Create a new account object representing the provided address\n * @param address A 56 character base-32 encoded Algorand address\n * @constructor\n */\nexport function Account(address: string): Account\nexport function Account(publicKeyOrAddress?: bytes | string): Account {\n  throw new NoImplementation()\n}\n\n/**\n * Creates a new Asset object represent the asset id 0 (an invalid ID)\n */\nexport function Asset(): Asset\n/**\n * Creates a new Asset object representing the asset with the specified id\n * @param assetId The id of the asset\n */\nexport function Asset(assetId: uint64): Asset\nexport function Asset(assetId?: uint64): Asset {\n  throw new NoImplementation()\n}\n/**\n * An Asset on the Algorand network.\n */\nexport type Asset = {\n  /**\n   * Returns the id of the Asset\n   */\n  readonly id: uint64\n\n  /**\n   * Total number of units of this asset\n   */\n  readonly total: uint64\n\n  /**\n   * @see AssetParams.decimals\n   */\n  readonly decimals: uint64\n\n  /**\n   * Frozen by default or not\n   */\n  readonly defaultFrozen: boolean\n\n  /**\n   * Asset unit name\n   */\n  readonly unitName: bytes\n\n  /**\n   * Asset name\n   */\n  readonly name: bytes\n\n  /**\n   * URL with additional info about the asset\n   */\n  readonly url: bytes\n\n  /**\n   * Arbitrary commitment\n   */\n  readonly metadataHash: bytes\n\n  /**\n   * Manager address\n   */\n  readonly manager: Account\n\n  /**\n   * Reserve address\n   */\n  readonly reserve: Account\n\n  /**\n   * Freeze address\n   */\n  readonly freeze: Account\n\n  /**\n   * Clawback address\n   */\n  readonly clawback: Account\n\n  /**\n   * Creator address\n   */\n  readonly creator: Account\n\n  /**\n   * Amount of the asset unit held by this account. Fails if the account has not\n   * opted in to the asset.\n   * Asset and supplied Account must be an available resource\n   * @param account Account\n   * @return balance: uint64\n   */\n  balance(account: Account): uint64\n\n  /**\n   * Is the asset frozen or not. Fails if the account has not\n   * opted in to the asset.\n   * Asset and supplied Account must be an available resource\n   * @param account Account\n   * @return isFrozen: boolean\n   */\n  frozen(account: Account): boolean\n}\n\n/**\n * Creates a new Application object represent the application id 0 (an invalid ID)\n */\nexport function Application(): Application\n/**\n * Creates a new Application object representing the application with the specified id\n * @param applicationId The id of the application\n */\nexport function Application(applicationId: uint64): Application\nexport function Application(applicationId?: uint64): Application {\n  throw new NoImplementation()\n}\n\n/**\n * An Application on the Algorand network.\n */\nexport type Application = {\n  /**\n   * The id of this application on the current network\n   */\n  readonly id: uint64\n  /**\n   * Bytecode of Approval Program\n   */\n  readonly approvalProgram: bytes\n\n  /**\n   * Bytecode of Clear State Program\n   */\n  readonly clearStateProgram: bytes\n\n  /**\n   * Number of uint64 values allowed in Global State\n   */\n  readonly globalNumUint: uint64\n\n  /**\n   * Number of byte array values allowed in Global State\n   */\n  readonly globalNumBytes: uint64\n\n  /**\n   * Number of uint64 values allowed in Local State\n   */\n  readonly localNumUint: uint64\n\n  /**\n   * Number of byte array values allowed in Local State\n   */\n  readonly localNumBytes: uint64\n\n  /**\n   * Number of Extra Program Pages of code space\n   */\n  readonly extraProgramPages: uint64\n\n  /**\n   * Creator address\n   */\n  readonly creator: Account\n\n  /**\n   * Address for which this application has authority\n   */\n  readonly address: Account\n}\n","import { NoImplementation } from './internal/errors'\nimport { bytes, uint64 } from './primitives'\n\n/**\n * A Box proxy\n * @typeParam TValue The type of the data stored in the box.\n */\nexport type Box<TValue> = {\n  /**\n   * Create the box for this proxy with a bzero value.\n   *  - If options.size is specified, the box will be created with that length\n   *  - Otherwise the box will be created with arc4EncodedLength(TValue). Errors if the encoded length is not fixed\n   *\n   * No op if the box already exists\n   * @returns True if the box was created, false if it already existed\n   */\n  create(options?: { size?: uint64 }): boolean\n  /**\n   * Get the key used by this box proxy\n   */\n  readonly key: bytes\n  /**\n   * Get or set the value stored in the box\n   *\n   * Get will error if the box does not exist\n   */\n  value: TValue\n  /**\n   * Get a boolean indicating if the box exists or not\n   */\n  readonly exists: boolean\n  /**\n   * Get the value stored in the box, or return a specified default value if the box does not exist\n   * @param options Options to specify a default value to be returned if no other value exists\n   * @returns The value if the box exists, else the default value\n   */\n  get(options: { default: TValue }): TValue\n  /**\n   * Delete the box associated with this proxy if it exists.\n   * @returns True if the box existed and was deleted, else false\n   */\n  delete(): boolean\n  /**\n   * Get the value stored in the box if available, and a boolean indicating if the box exists.\n   *\n   * If the box does not exist, the value returned at position 0 should not be relied on to have a valid value.\n   * @returns A tuple with the first item being the box value, and the second item being a boolean indicating if the box exists.\n   */\n  maybe(): readonly [TValue, boolean]\n  /**\n   * Returns the length of the box, or error if the box does not exist\n   */\n  readonly length: uint64\n}\n/**\n * A BoxMap proxy\n * @typeParam TKey The type of the value used to key each box.\n * @typeParam TValue The type of the data stored in the box.\n */\nexport type BoxMap<TKey, TValue> = {\n  /**\n   * Get the bytes used to prefix each key\n   */\n  readonly keyPrefix: bytes\n\n  /**\n   * Get a Box proxy for a single item in the BoxMap\n   * @param key The key of the box to retrieve a proxy for\n   */\n  (key: TKey): Box<TValue>\n}\n\n/**\n * A BoxRef proxy\n */\nexport type BoxRef = {\n  /**\n   * Get the key used by this box proxy\n   */\n  readonly key: bytes\n  /**\n   * Get a boolean indicating if the box exists or not\n   */\n  readonly exists: boolean\n  /**\n   * Get the value of the box.\n   *\n   * Error if this value is larger than what the `bytes` type supports\n   * Error if getting the value and the box does not exist\n   */\n  value: bytes\n  /**\n   * Get the value stored in the box, or return a specified default value if the box does not exist\n   * @param options Options to specify a default value to be returned if no other value exists\n   * @returns The value if the box exists, else the default value\n   */\n  get(options: { default: bytes }): bytes\n  /**\n   * Puts the specified bytes into the box replacing any existing value.\n   *\n   * Creates the box if it does not exist\n   * Errors if the box exists, but the length does not match the length of `value`\n   * @param value The value to put into the box\n   */\n  put(value: bytes): void\n  /**\n   * Splice the specified bytes into the box starting at `start`, removing `length` bytes\n   * from the existing value and replacing them with `value` before appending the remainder of the original box value.\n   *\n   * If the resulting byte value is larger than length, bytes will be trimmed from the end\n   * If the resulting byte value is smaller than length, zero bytes will be appended to the end\n   * Error if the box does not exist\n   * @param start The index to start inserting the value\n   * @param length The number of bytes after `start` to be omitted\n   * @param value The value to be inserted\n   */\n  splice(start: uint64, length: uint64, value: bytes): void\n  /**\n   * Replace bytes in a box starting at `start`.\n   *\n   * Error if the box does not exist\n   * Error if `start` + `value.length` is greater than the box size\n   * @param start The index to start replacing\n   * @param value The value to be written\n   */\n  replace(start: uint64, value: bytes): void\n  /**\n   * Extract a slice of bytes from the box\n   *\n   * Error if the box does not exist\n   * Error if `start` + `length` is greater than the box size\n   * @param start The index to start extracting\n   * @param length The number of bytes to extract\n   * @returns The extracted bytes\n   */\n  extract(start: uint64, length: uint64): bytes\n  /**\n   * Delete the box associated with this proxy if it exists.\n   * @returns True if the box existed and was deleted, else false\n   */\n  delete(): boolean\n  /**\n   * Create the box for this proxy with the specified size if it does not exist\n   *\n   * No op if the box already exists\n   * @param options The size of the box to create\n   * @returns True if the box was created, false if it already existed\n   */\n  create(options: { size: uint64 }): boolean\n  /**\n   * Resize the box to the specified size.\n   *\n   * Adds zero bytes to the end if the new size is larger\n   * Removes end bytes if the new size is smaller\n   * Error if the box does not exist\n   * @param newSize The new size for the box\n   */\n  resize(newSize: uint64): void\n  /**\n   * Get the value stored in the box if available, and a boolean indicating if the box exists.\n   *\n   * If the box does not exist, the value returned at position 0 will be an empty byte array.\n   * @returns A tuple with the first item being the box value, and the second item being a boolean indicating if the box exists.\n   */\n  maybe(): readonly [bytes, boolean]\n  /**\n   * Returns the length of the box, or error if the box does not exist\n   */\n  readonly length: uint64\n}\n\n/**\n * Options for creating a Box proxy\n */\ninterface CreateBoxOptions {\n  /**\n   * The bytes which make up the key of the box\n   */\n  key: bytes | string\n}\n\n/**\n * Creates a Box proxy object offering methods of getting and setting the value stored in a single box.\n * @param options Options for creating the Box proxy\n * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.\n */\nexport function Box<TValue>(options: CreateBoxOptions): Box<TValue> {\n  throw new NoImplementation()\n}\n\n/**\n * Options for creating a BoxMap proxy\n */\ninterface CreateBoxMapOptions {\n  /**\n   * The bytes which prefix each key of the box map\n   */\n  keyPrefix: bytes | string\n}\n\n/**\n * Creates a BoxMap proxy object offering methods of getting and setting a set of values stored in individual boxes indexed by a common key type\n * @param options Options for creating the BoxMap proxy\n * @typeParam TKey The type of the value used to key each box. This key will be encoded to bytes and prefixed with `keyPrefix`\n * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.\n */\nexport function BoxMap<TKey, TValue>(options: CreateBoxMapOptions): BoxMap<TKey, TValue> {\n  throw new NoImplementation()\n}\n\n/**\n * Options for creating a BoxRef proxy\n */\ninterface CreateBoxRefOptions {\n  /**\n   * The bytes which make up the key of the box\n   */\n  key: bytes | string\n}\n\n/**\n * Creates a BoxRef proxy object offering methods for getting and setting binary data in a box under a single key. This proxy is particularly\n * relevant when dealing with binary data that is larger than what the AVM can handle in a single value.\n * @param options The options for creating the BoxRef proxy\n */\nexport function BoxRef(options: CreateBoxRefOptions): BoxRef {\n  throw new NoImplementation()\n}\n","import { NoImplementation } from './internal/errors'\nimport { bytes } from './primitives'\nimport { Account } from './reference'\n\n/**\n * A proxy for manipulating a global state field\n * @typeParam ValueType The type of the value being stored - must be a serializable type\n */\nexport type GlobalState<ValueType> = {\n  /**\n   * Get or set the value of this global state field\n   */\n  value: ValueType\n  /**\n   * Delete the stored value of this global state field\n   */\n  delete(): void\n  /**\n   * Gets a boolean value indicating if global state field currently has a value\n   */\n  readonly hasValue: boolean\n}\n/**\n * Options for declaring a global state field\n */\nexport type GlobalStateOptions<ValueType> = {\n  /**\n   * The key to be used for this global state field.\n   *\n   * Defaults to the name of the property this proxy is assigned to\n   */\n  key?: bytes | string\n  /**\n   * An initial value to assign to this global state field when the application is created\n   */\n  initialValue?: ValueType\n}\n\n/**\n * Creates a new proxy for manipulating a global state field\n * @param options Options for configuring this field\n * @typeParam ValueType The type of the value being stored - must be a serializable type\n */\nexport function GlobalState<ValueType>(options?: GlobalStateOptions<ValueType>): GlobalState<ValueType> {\n  throw new NoImplementation()\n}\n\n/**\n * A proxy for manipulating a local state field for a single account\n */\nexport type LocalStateForAccount<ValueType> = {\n  /**\n   * Get or set the value of this local state field for a single account\n   */\n  value: ValueType\n  /**\n   * Delete the stored value of this local state field for a single account\n   */\n  delete(): void\n  /**\n   * Gets a boolean value indicating if local state field for a single account currently has a value\n   */\n  readonly hasValue: boolean\n}\n\n/**\n * A proxy for manipulating a local state field for any account\n */\nexport type LocalState<ValueType> = {\n  /**\n   * Gets the LocalState proxy for a specific account\n   * @param account The account to read or write state for. This account must be opted into the contract\n   */\n  (account: Account): LocalStateForAccount<ValueType>\n}\n/**\n * Options for declaring a local state field\n */\nexport type LocalStateOptions = {\n  /**\n   * The key to be used for this local state field.\n   *\n   * Defaults to the name of the property this proxy is assigned to\n   */\n  key?: bytes | string\n}\n\n/**\n * Creates a new proxy for manipulating a local state field\n * @param options Options for configuring this field\n */\nexport function LocalState<ValueType>(options?: LocalStateOptions): LocalState<ValueType> {\n  throw new NoImplementation()\n}\n","/**\n * The different transaction types available in a transaction\n */\nexport enum TransactionType {\n  /**\n   * A Payment transaction\n   */\n  Payment = 1,\n  /**\n   * A Key Registration transaction\n   */\n  KeyRegistration = 2,\n  /**\n   * An Asset Config transaction\n   */\n  AssetConfig = 3,\n  /**\n   * An Asset Transfer transaction\n   */\n  AssetTransfer = 4,\n  /**\n   * An Asset Freeze transaction\n   */\n  AssetFreeze = 5,\n  /**\n   * An Application Call transaction\n   */\n  ApplicationCall = 6,\n}\n","import { ConstructorFor } from './internal/typescript-helpers'\nimport { uint64 } from './primitives'\n\n/**\n * Base class for Algorand TypeScript Logic Signatures (also known as Smart Signatures)\n */\nexport abstract class LogicSig {\n  /**\n   * The logic signature program logic\n   */\n  abstract program(): boolean | uint64\n}\n\n/**\n * Alias for a numeric range specification.\n */\ntype NumberRange = {\n  /**\n   * The start point of the range (inclusive)\n   */\n  from: number\n  /**\n   * The end point of the range (inclusive)\n   */\n  to: number\n}\n\n/**\n * Defines optional configuration for a logic signature\n */\ntype LogicSigOptions = {\n  /**\n   * Determines which AVM version to use, this affects what operations are supported.\n   * Defaults to value provided supplied on command line (which defaults to current mainnet version)\n   */\n  avmVersion?: 10 | 11\n  /**\n   * Override the name of the logic signature when generating build artifacts.\n   * Defaults to the class name\n   */\n  name?: string\n  /**\n   * Allows you to mark a slot ID or range of slot IDs as \"off limits\" to Puya.\n   * These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.\n   * This is particularly useful in combination with `op.gload_bytes` / `op.gload_uint64`\n   * which lets a contract in a group transaction read from the scratch slots of another contract\n   * that occurs earlier in the transaction group.\n   */\n  scratchSlots?: Array<number | NumberRange>\n}\n\n/**\n * The logicsig decorator can be used to specify additional configuration options for a logic signature\n * @param options An object containing the configuration options\n */\nexport function logicsig(options: LogicSigOptions) {\n  return <T extends ConstructorFor<LogicSig>>(logicSig: T) => logicSig\n}\n","import { NoImplementation } from './internal/errors'\n\n/**\n * Declare a template variable which can be replaced at compile time with an environment specific value.\n *\n * The final variable name will be `prefix + variableName`\n * @param variableName The key used to identify the variable.\n * @param prefix The prefix to apply the variable name (Defaults to 'TMPL_')\n */\nexport function TemplateVar<T>(variableName: string, prefix = 'TMPL_'): T {\n  throw new NoImplementation()\n}\n","import { BaseContract } from './base-contract'\nimport { NoImplementation } from './internal/errors'\nimport { ConstructorFor, DeliberateAny } from './internal/typescript-helpers'\nimport { LogicSig } from './logic-sig'\nimport { bytes, uint64 } from './primitives'\nimport { Account } from './reference'\n\n/**\n * Provides compiled programs and state allocation values for a Contract. Created by calling `compile(ExampleContractType)`\n */\nexport type CompiledContract = {\n  /**\n   * Approval program pages for a contract, after template variables have been replaced and compiled to AVM bytecode\n   */\n  approvalProgram: [bytes, bytes]\n  /**\n   * Clear state program pages for a contract, after template variables have been replaced and compiled to AVM bytecode\n   */\n  clearStateProgram: [bytes, bytes]\n  /**\n   * By default, provides extra program pages required based on approval and clear state program size, can be overridden when calling `compile(ExampleContractType, { extraProgramPages: ... })`\n   */\n  extraProgramPages: uint64\n  /**\n   * By default, provides global num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalUints: ... })`\n   */\n  globalUints: uint64\n  /**\n   * By default, provides global num bytes based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalBytes: ... })`\n   */\n  globalBytes: uint64\n  /**\n   * By default, provides local num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { localUints: ... })`\n   */\n  localUints: uint64\n  /**\n   * By default, provides local num bytes based on contract state totals, can be overridden  when calling `compile(ExampleContractType, { localBytes: ... })`\n   */\n  localBytes: uint64\n}\n\n/**\n * Provides account for a Logic Signature. Created by calling `compile(LogicSigType)`\n */\nexport type CompiledLogicSig = {\n  /**\n   * Address of a logic sig program, after template variables have been replaced and compiled to AVM bytecode\n   */\n  account: Account\n}\n\n/**\n * Options for compiling a contract\n */\nexport type CompileContractOptions = {\n  /**\n   * Number of extra program pages, defaults to minimum required for contract\n   */\n  extraProgramPages?: uint64\n  /**\n   * Number of global uint64s, defaults to value defined for contract\n   */\n  globalUints?: uint64\n  /**\n   * Number of global bytes, defaults to value defined for contract\n   */\n  globalBytes?: uint64\n  /**\n   * Number of local uint64s, defaults to value defined for contract\n   */\n  localUints?: uint64\n  /**\n   * Number of local bytes, defaults to value defined for contract\n   */\n  localBytes?: uint64\n  /**\n   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant\n   * and match the type of the template var declaration\n   */\n  templateVars?: Record<string, DeliberateAny>\n  /**\n   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)\n   */\n  templateVarsPrefix?: string\n}\n\n/**\n * Options for compiling a logic signature\n */\nexport type CompileLogicSigOptions = {\n  /**\n   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant\n   * and match the type of the template var declaration\n   */\n  templateVars?: Record<string, DeliberateAny>\n  /**\n   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)\n   */\n  templateVarsPrefix?: string\n}\n\n/**\n * Compile a contract and return the resulting byte code for approval and clear state programs.\n * @param contract The contract class to compile\n * @param options Options for compiling the contract\n */\nexport function compile(contract: ConstructorFor<BaseContract>, options?: CompileContractOptions): CompiledContract\n/**\n * Compile a logic signature and return an account ready for signing transactions.\n * @param logicSig The logic sig class to compile\n * @param options Options for compiling the logic sig\n */\nexport function compile(logicSig: ConstructorFor<LogicSig>, options?: CompileLogicSigOptions): CompiledLogicSig\nexport function compile(artefact: ConstructorFor<BaseContract> | ConstructorFor<LogicSig>): CompiledLogicSig | CompiledContract {\n  throw new NoImplementation()\n}\n","import { NoImplementation } from './internal/errors'\nimport { uint64, Uint64Compat } from './primitives'\n\n/**\n * An in memory mutable array which is passed by reference\n */\nexport class MutableArray<TItem> {\n  /**\n   * Create a new MutableArray with the specified items\n   * @param items The initial items for the array\n   */\n  constructor(...items: TItem[]) {}\n\n  /**\n   * Returns the current length of this array\n   */\n  get length(): uint64 {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the item at the given index.\n   * Negative indexes are taken from the end.\n   * @param index The index of the item to retrieve\n   */\n  at(index: Uint64Compat): TItem {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Create a new Dynamic array with all items from this array\n   * @internal Not supported yet\n   */\n  slice(): MutableArray<TItem>\n  /**\n   * Create a new MutableArray with all items up till `end`.\n   * Negative indexes are taken from the end.\n   * @param end An index in which to stop copying items.\n   * @internal Not supported yet\n   */\n  slice(end: Uint64Compat): MutableArray<TItem>\n  /**\n   * Create a new MutableArray with items from `start`, up until `end`\n   * Negative indexes are taken from the end.\n   * @param start An index in which to start copying items.\n   * @param end An index in which to stop copying items\n   * @internal Not supported yet\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): MutableArray<TItem>\n  slice(start?: Uint64Compat, end?: Uint64Compat): MutableArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the items in this array\n   */\n  [Symbol.iterator](): IterableIterator<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for a tuple of the indexes and items in this array\n   */\n  entries(): IterableIterator<readonly [uint64, TItem]> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the indexes in this array\n   */\n  keys(): IterableIterator<uint64> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Get or set the item at the specified index.\n   * Negative indexes are not supported\n   */\n  [index: uint64]: TItem\n\n  /**\n   * Push a number of items into this array\n   * @param items The items to be added to this array\n   */\n  push(...items: TItem[]): void {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Pop a single item from this array\n   */\n  pop(): TItem {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Create a copy of this array\n   */\n  copy(): MutableArray<TItem> {\n    throw new NoImplementation()\n  }\n}\n","import { NoImplementation } from './internal/errors'\nimport { DeliberateAny } from './internal/typescript-helpers'\n\n/**\n * Emit an arc28 event log using either an ARC4Struct type or a named object type.\n * Object types must have an ARC4 equivalent type.\n *\n * Anonymous types cannot be used as the type name is used to determine the event prefix\n * @param event An ARC4Struct instance, or a plain object with a named type\n *\n * @example\n * class Demo extends Struct<{ a: UintN64 }> {}\n * emit(new Demo({ a: new UintN64(123) }))\n *\n * @example\n * type Demo = { a: uint64 }\n * emit<Demo>({a: 123})\n * // or\n * const d: Demo = { a: 123 }\n * emit(d)\n */\nexport function emit<TEvent extends Record<string, DeliberateAny>>(event: TEvent): void\n/**\n * Emit an arc28 event log using an explicit name and inferred property/field types.\n * Property types must be ARC4 or have an ARC4 equivalent type.\n * @param eventName The name of the event (must be a compile time constant)\n * @param eventProps A set of event properties (order is significant)\n *\n * @example\n * emit(\"Demo\", new UintN64(123))\n *\n * @example\n * const a: uint64 = 123\n * emit(\"Demo\", a)\n */\nexport function emit<TProps extends [...DeliberateAny[]]>(eventName: string, ...eventProps: TProps): void\nexport function emit<T>(event: T | string, ...eventProps: unknown[]): void {\n  throw new NoImplementation()\n}\n","/**\n * The possible on complete actions a method can handle, represented as a string\n */\nexport type OnCompleteActionStr = 'NoOp' | 'OptIn' | 'ClearState' | 'CloseOut' | 'UpdateApplication' | 'DeleteApplication'\n\n/**\n * The possible on complete actions a method can handle, represented as an integer\n */\nexport enum OnCompleteAction {\n  /**\n   * Do nothing after the transaction has completed\n   */\n  NoOp = 0,\n  /**\n   * Opt the calling user into the contract\n   */\n  OptIn = 1,\n  /**\n   * Close the calling user out of the contract\n   */\n  CloseOut = 2,\n  /**\n   * Run the clear state program and forcibly close the user out of the contract\n   */\n  ClearState = 3,\n  /**\n   * Replace the application's approval and clear state programs with the bytes from this transaction\n   */\n  UpdateApplication = 4,\n  /**\n   * Delete the application\n   */\n  DeleteApplication = 5,\n}\n"],"names":[],"mappings":"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"}