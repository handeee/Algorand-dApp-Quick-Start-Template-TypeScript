{"version":3,"file":"index-dzo0agbK.js","sources":["../src/base-contract.ts","../src/arc4/encoded-types.ts","../src/arc4/c2c.ts","../src/arc4/index.ts"],"sourcesContent":["import { NoImplementation } from './internal/errors'\nimport { ConstructorFor } from './internal/typescript-helpers'\nimport { uint64 } from './primitives'\nimport { NumberRange } from './util'\n\n/**\n * The base type for all Algorand TypeScript contracts\n */\nexport abstract class BaseContract {\n  /**\n   * The program to be run when the On Completion Action is != ClearState (3)\n   */\n  public abstract approvalProgram(): boolean | uint64\n\n  /**\n   * The program to be run when the On Completion Action is == ClearState (3)\n   */\n  public clearStateProgram(): boolean | uint64 {\n    return true\n  }\n}\n\n/**\n * Options class to manually define the total amount of global and local state contract will use.\n *\n * This is not required when all state is assigned to `this.`, but is required if a\n * contract dynamically interacts with state via `AppGlobal.getBytes` etc, or if you want\n * to reserve additional state storage for future contract updates, since the Algorand protocol\n * doesn't allow increasing them after creation.\n */\nexport type StateTotals = {\n  globalUints?: number\n  globalBytes?: number\n  localUints?: number\n  localBytes?: number\n}\n\n/**\n * Additional configuration options for a contract\n */\nexport type ContractOptions = {\n  /**\n   * Determines which AVM version to use, this affects what operations are supported.\n   * Defaults to value provided supplied on command line (which defaults to current mainnet version)\n   */\n  avmVersion?: 10 | 11\n\n  /**\n   * Override the name of the logic signature when generating build artifacts.\n   * Defaults to the class name\n   */\n  name?: string\n  /**\n   * Allows you to mark a slot ID or range of slot IDs as \"off limits\" to Puya.\n   * These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.\n   * This is particularly useful in combination with `op.gload_bytes` / `op.gload_uint64`\n   * which lets a contract in a group transaction read from the scratch slots of another contract\n   * that occurs earlier in the transaction group.\n   *\n   * In the case of inheritance, scratch slots reserved become cumulative. It is not an error\n   * to have overlapping ranges or values either, so if a base class contract reserves slots\n   * 0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived\n   * contract all slots 0-10 will be marked as reserved.\n   */\n  scratchSlots?: Array<number | NumberRange>\n  /**\n   * Allows defining what values should be used for global and local uint and bytes storage\n   * values when creating a contract. Used when outputting ARC-32 application.json schemas.\n   *\n   * If left unspecified, the totals will be determined by the compiler based on state\n   * variables assigned to `this`.\n   *\n   * This setting is not inherited, and only applies to the exact `Contract` it is specified\n   * on. If a base class does specify this setting, and a derived class does not, a warning\n   * will be emitted for the derived class. To resolve this warning, `stateTotals` must be\n   * specified. An empty object may be provided in order to indicate that this contract should\n   * revert to the default behaviour\n   */\n  stateTotals?: StateTotals\n}\n\n/**\n * The contract decorator can be used to specify additional configuration options for a smart contract\n * @param options An object containing the configuration options\n */\nexport function contract(options: ContractOptions) {\n  return <T extends ConstructorFor<BaseContract>>(contract: T, ctx: ClassDecoratorContext) => {\n    throw new NoImplementation()\n  }\n}\n","import { NoImplementation } from '../internal/errors'\nimport { biguint, BigUintCompat, bytes, BytesBacked, BytesCompat, NTuple, StringCompat, uint64, Uint64Compat } from '../primitives'\nimport { Account } from '../reference'\n\n/**\n * Defines UintN bit sizes which are compatible with the uint64 type\n */\ntype UintBitSize = 8 | 16 | 24 | 32 | 40 | 48 | 56 | 64\n/**\n * Defines UintN bit sizes which are only compatible with the biguint type\n */\ntype BigUintBitSize =\n  | 72\n  | 80\n  | 88\n  | 96\n  | 104\n  | 112\n  | 120\n  | 128\n  | 136\n  | 144\n  | 152\n  | 160\n  | 168\n  | 176\n  | 184\n  | 192\n  | 200\n  | 208\n  | 216\n  | 224\n  | 232\n  | 240\n  | 248\n  | 256\n  | 264\n  | 272\n  | 280\n  | 288\n  | 296\n  | 304\n  | 312\n  | 320\n  | 328\n  | 336\n  | 344\n  | 352\n  | 360\n  | 368\n  | 376\n  | 384\n  | 392\n  | 400\n  | 408\n  | 416\n  | 424\n  | 432\n  | 440\n  | 448\n  | 456\n  | 464\n  | 472\n  | 480\n  | 488\n  | 496\n  | 504\n  | 512\n/**\n * Defines supported bit sizes for the UintN and UFixedNxM types\n */\nexport type BitSize = UintBitSize | BigUintBitSize\n/**\n * Conditional type which returns the native equivalent type for a given UintN bit size\n */\ntype NativeForArc4Int<N extends BitSize> = N extends UintBitSize ? uint64 : biguint\n/**\n * Conditional type which returns the compat type relevant to a given UintN bit size\n */\ntype CompatForArc4Int<N extends BitSize> = N extends UintBitSize ? Uint64Compat : BigUintCompat\n\n/**\n * @hidden\n */\nconst TypeProperty = Symbol('ARC4Type')\n\n/**\n * A base type for ARC4 encoded values\n */\nexport abstract class ARC4Encoded implements BytesBacked {\n  /** @hidden */\n  abstract [TypeProperty]?: string\n\n  /**\n   * Retrieve the encoded bytes for this type\n   */\n  get bytes(): bytes {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A utf8 encoded string prefixed with its length expressed as a 2 byte uint\n */\nexport class Str extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty]?: 'arc4.Str'\n\n  /**\n   * Create a new Str instance\n   * @param s The native string to initialize this Str from\n   */\n  constructor(s?: StringCompat) {\n    super()\n  }\n\n  /**\n   * Retrieve the decoded native string\n   */\n  get native(): string {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A fixed bit size unsigned int\n */\nexport class UintN<N extends BitSize> extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty]?: `arc4.UintN<${N}>`\n\n  /**\n   * Create a new UintN instance\n   * @param v The native uint64 or biguint value to initialize this UintN from\n   */\n  constructor(v?: CompatForArc4Int<N>) {\n    super()\n  }\n\n  /**\n   * Retrieve the decoded native uint64 or biguint\n   */\n  get native(): NativeForArc4Int<N> {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * An alias for UintN<8>\n */\nexport class Byte extends UintN<8> {}\n\n/**\n * An alias for UintN<8>\n */\nexport class UintN8 extends UintN<8> {}\n\n/**\n * An alias for UintN<16>\n */\nexport class UintN16 extends UintN<16> {}\n\n/**\n * An alias for UintN<32>\n */\nexport class UintN32 extends UintN<32> {}\n\n/**\n * An alias for UintN<64>\n */\nexport class UintN64 extends UintN<64> {}\n\n/**\n * An alias for UintN<128>\n */\nexport class UintN128 extends UintN<128> {}\n\n/**\n * An alias for UintN<256>\n */\nexport class UintN256 extends UintN<256> {}\n\n/**\n * A fixed bit size, fixed decimal unsigned value\n */\nexport class UFixedNxM<N extends BitSize, M extends number> extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty]?: `arc4.UFixedNxM<${N}x${M}>`\n\n  /**\n   * Create a new UFixedNxM value\n   * @param v A string representing the integer and fractional portion of the number\n   */\n  constructor(v?: `${number}.${number}`) {\n    super()\n  }\n\n  /**\n   * Retrieve the decoded native uint64 or biguint where the returned integer represents the fixed decimal value * (10 ^ M)\n   */\n  get native(): NativeForArc4Int<N> {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A boolean value\n */\nexport class Bool extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty]?: `arc4.Bool`\n\n  /**\n   * Create a new Bool value\n   * @param v The native boolean to initialize this value from\n   */\n  constructor(v?: boolean) {\n    super()\n  }\n\n  /**\n   * Get the decoded native boolean for this value\n   */\n  get native(): boolean {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A base type for arc4 array types\n */\nabstract class Arc4ArrayBase<TItem extends ARC4Encoded> extends ARC4Encoded {\n  protected constructor() {\n    super()\n  }\n\n  /**\n   * Returns the current length of this array\n   */\n  get length(): uint64 {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the item at the given index.\n   * Negative indexes are taken from the end.\n   * @param index The index of the item to retrieve\n   */\n  at(index: Uint64Compat): TItem {\n    throw new NoImplementation()\n  }\n\n  /** @internal\n   * Create a new Dynamic array with all items from this array\n   */\n  slice(): DynamicArray<TItem>\n  /** @internal\n   * Create a new DynamicArray with all items up till `end`.\n   * Negative indexes are taken from the end.\n   * @param end An index in which to stop copying items.\n   */\n  slice(end: Uint64Compat): DynamicArray<TItem>\n  /** @internal\n   * Create a new DynamicArray with items from `start`, up until `end`\n   * Negative indexes are taken from the end.\n   * @param start An index in which to start copying items.\n   * @param end An index in which to stop copying items\n   */\n  slice(start: Uint64Compat, end: Uint64Compat): DynamicArray<TItem>\n  slice(start?: Uint64Compat, end?: Uint64Compat): DynamicArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the items in this array\n   */\n  [Symbol.iterator](): IterableIterator<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for a tuple of the indexes and items in this array\n   */\n  entries(): IterableIterator<readonly [uint64, TItem]> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns an iterator for the indexes in this array\n   */\n  keys(): IterableIterator<uint64> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Get or set the item at the specified index.\n   * Negative indexes are not supported\n   */\n  [index: uint64]: TItem\n}\n\n/**\n * A fixed sized array of arc4 items\n * @typeParam TItem The type of a single item in the array\n * @typeParam TLength The fixed length of the array\n */\nexport class StaticArray<TItem extends ARC4Encoded, TLength extends number> extends Arc4ArrayBase<TItem> {\n  /** @hidden */\n  [TypeProperty]?: `arc4.StaticArray<${TItem[typeof TypeProperty]}, ${TLength}>`\n\n  /**\n   * Create a new StaticArray instance\n   */\n  constructor()\n  /**\n   * Create a new StaticArray instance with the specified items\n   * @param items The initial items for the array\n   */\n  constructor(...items: TItem[] & { length: TLength })\n  constructor(...items: TItem[] & { length: TLength }) {\n    super()\n  }\n\n  /**\n   * Returns a copy of this array\n   */\n  copy(): StaticArray<TItem, TLength> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a new array containing all items from _this_ array, and _other_ array\n   * @param other Another array to concat with this one\n   */\n  concat(other: Arc4ArrayBase<TItem>): DynamicArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Return the array items as a native tuple\n   */\n  get native(): NTuple<TItem, TLength> {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A dynamic sized array of arc4 items\n * @typeParam TItem The type of a single item in the array\n */\nexport class DynamicArray<TItem extends ARC4Encoded> extends Arc4ArrayBase<TItem> {\n  /** @hidden */\n  [TypeProperty]?: `arc4.DynamicArray<${TItem[typeof TypeProperty]}>`\n\n  /**\n   * Create a new DynamicArray with the specified items\n   * @param items The initial items for the array\n   */\n  constructor(...items: TItem[]) {\n    super()\n  }\n\n  /**\n   * Push a number of items into this array\n   * @param items The items to be added to this array\n   */\n  push(...items: TItem[]): void {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Pop a single item from this array\n   */\n  pop(): TItem {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a copy of this array\n   */\n  copy(): DynamicArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a new array containing all items from _this_ array, and _other_ array\n   * @param other Another array to concat with this one\n   */\n  concat(other: Arc4ArrayBase<TItem>): DynamicArray<TItem> {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Return the array items as a native immutable array\n   */\n  get native(): TItem[] {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * @hidden\n */\ntype ExpandTupleType<T extends ARC4Encoded[]> = T extends [infer T1 extends ARC4Encoded, ...infer TRest extends ARC4Encoded[]]\n  ? TRest extends []\n    ? `${T1[typeof TypeProperty]}`\n    : `${T1[typeof TypeProperty]},${ExpandTupleType<TRest>}`\n  : ''\n\n/**\n * An arc4 encoded tuple of values\n * @typeParam TTuple A type representing the native tuple of item types\n */\nexport class Tuple<TTuple extends [ARC4Encoded, ...ARC4Encoded[]]> extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty]?: `arc4.Tuple<${ExpandTupleType<TTuple>}>`\n\n  /**\n   * Create a new Tuple with the default zero values for items\n   */\n  constructor()\n  /**\n   * Create a new Tuple with the specified items\n   * @param items The tuple items\n   */\n  constructor(...items: TTuple)\n  constructor(...items: TTuple | []) {\n    super()\n  }\n\n  /**\n   * Returns the item at the specified index\n   * @param index The index of the item to get. Must be a positive literal representing a tuple index\n   */\n  at<TIndex extends keyof TTuple>(index: TIndex): TTuple[TIndex] {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the length of this tuple\n   */\n  get length(): TTuple['length'] & uint64 {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns the decoded native tuple (with arc4 encoded items)\n   */\n  get native(): TTuple {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A 32 byte Algorand Address\n */\nexport class Address extends Arc4ArrayBase<Byte> {\n  /** @hidden */\n  [TypeProperty]?: `arc4.Address`\n\n  /**\n   * Create a new Address instance\n   * @param value An Account, base 32 address string, or the address bytes\n   */\n  constructor(value?: Account | string | bytes) {\n    super()\n  }\n\n  /**\n   * Returns an Account instance for this Address\n   */\n  get native(): Account {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * The base type for arc4 structs\n */\nclass StructBase<T> extends ARC4Encoded {\n  /** @hidden */\n  [TypeProperty] = 'arc4.Struct'\n\n  get native(): T {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a deep copy of this struct\n   */\n  copy(): this {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * Type alias for the Struct constructor function\n * @typeParam T The shape of the arc4 struct\n */\ntype StructConstructor = {\n  new <T extends Record<string, ARC4Encoded>>(initial: T): StructBase<T> & T\n}\n\n/**\n * The base type of arc4 structs\n *\n * Usage:\n * ```\n * class MyStruct extends Struct<{ x: UintN8, y: Str, z: DynamicBytes }> {}\n * ```\n */\nexport const Struct = StructBase as unknown as StructConstructor\n\n/**\n * A variable length sequence of bytes prefixed with its length expressed as a 2 byte uint\n */\nexport class DynamicBytes extends Arc4ArrayBase<Byte> {\n  /** @hidden */\n  [TypeProperty]?: `arc4.DynamicBytes`\n\n  /**\n   * Create a new DynamicBytes instance\n   * @param value The bytes or utf8 interpreted string to initialize this type\n   */\n  constructor(value?: bytes | string) {\n    super()\n  }\n\n  /**\n   * Get the native bytes value (excludes the length prefix)\n   */\n  get native(): bytes {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a dynamic bytes object containing all bytes from _this_ and _other_\n   * @param other Another array of bytes to concat with this one\n   */\n  concat(other: Arc4ArrayBase<Byte>): DynamicBytes {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * A fixed length sequence of bytes\n */\nexport class StaticBytes<TLength extends number = 0> extends Arc4ArrayBase<Byte> {\n  /** @hidden */\n  [TypeProperty]?: `arc4.StaticBytes<${TLength}>`\n\n  /**\n   * Create a new StaticBytes instance\n   * @param value THe bytes or utf8 interpreted string to initialize this type\n   */\n  constructor(value?: bytes | string) {\n    super()\n  }\n\n  /**\n   * Get the native bytes value\n   */\n  get native(): bytes {\n    throw new NoImplementation()\n  }\n\n  /**\n   * Returns a dynamic bytes object containing all bytes from _this_ and _other_\n   * @param other Another array of bytes to concat with this one\n   */\n  concat(other: Arc4ArrayBase<Byte>): DynamicBytes {\n    throw new NoImplementation()\n  }\n}\n","import { CompileContractOptions, CompiledContract } from '../compiled'\nimport * as gtxn from '../gtxn'\nimport { NoImplementation } from '../internal/errors'\nimport { AnyFunction, ConstructorFor, DeliberateAny, InstanceMethod } from '../internal/typescript-helpers'\nimport * as itxn from '../itxn'\nimport { ApplicationCallFields, ApplicationCallInnerTxn } from '../itxn'\nimport { Contract } from './index'\n\n/**\n * Defines txn fields that are available for a bare create application call.\n *\n * This is the regular application call fields minus:\n *  - appId: because the appId is not known when creating an application\n *  - appArgs: because a bare call cannot have arguments\n */\nexport type BareCreateApplicationCallFields = Omit<ApplicationCallFields, 'appId' | 'appArgs'>\n\n/**\n * Conditional type which given a group transaction type, returns the equivalent inner transaction\n * params type.\n */\nexport type GtxnToItxnFields<T extends gtxn.Transaction> = T extends gtxn.PaymentTxn\n  ? itxn.PaymentItxnParams\n  : T extends gtxn.KeyRegistrationTxn\n    ? itxn.KeyRegistrationItxnParams\n    : T extends gtxn.AssetConfigTxn\n      ? itxn.AssetConfigItxnParams\n      : T extends gtxn.AssetTransferTxn\n        ? itxn.AssetTransferItxnParams\n        : T extends gtxn.AssetFreezeTxn\n          ? itxn.AssetFreezeItxnParams\n          : T extends gtxn.ApplicationCallTxn\n            ? itxn.ApplicationCallItxnParams\n            : itxn.ItxnParams\n\n/**\n * Conditional type which given an application argument, returns the input type for that argument.\n *\n * The input type will usually be the original type apart from group transactions which will be substituted\n * with their equivalent inner transaction type.\n */\nexport type TypedApplicationArg<TArg> = TArg extends gtxn.Transaction ? GtxnToItxnFields<TArg> : TArg\n\n/**\n * Conditional type which maps a tuple of application arguments to a tuple of input types for specifying those arguments.\n */\nexport type TypedApplicationArgs<TArgs> = TArgs extends []\n  ? []\n  : TArgs extends [infer TArg, ...infer TRest]\n    ? [TypedApplicationArg<TArg>, ...TypedApplicationArgs<TRest>]\n    : never\n\n/**\n * Application call fields with `appArgs` replaced with an `args` property that is strongly typed to the actual arguments for the\n * given application call.\n */\nexport type TypedApplicationCallFields<TArgs> = Omit<ApplicationCallFields, 'appArgs'> &\n  (TArgs extends [] ? { args?: TypedApplicationArgs<TArgs> } : { args: TypedApplicationArgs<TArgs> })\n\n/**\n * The response type of a typed application call. Includes the raw itxn result object and the parsed ABI return value if applicable.\n */\nexport type TypedApplicationCallResponse<TReturn> = TReturn extends void\n  ? { itxn: ApplicationCallInnerTxn }\n  : { itxn: ApplicationCallInnerTxn; returnValue: TReturn }\n\n/**\n * Conditional type which maps an ABI method to a factory method for constructing an application call transaction to call that method.\n */\nexport type ContractProxyMethod<TMethod> = TMethod extends (...args: infer TArgs) => infer TReturn\n  ? (fields?: TypedApplicationCallFields<TArgs>) => TypedApplicationCallResponse<TReturn>\n  : never\n\n/**\n * Conditional type which maps an ARC4 compatible contract to a proxy object which allows for constructing application call transactions for\n * all available ABI and bare methods. Also includes the compiled contract result data.\n */\nexport type ContractProxy<TContract extends Contract> = CompiledContract & {\n  /**\n   * Get methods for calling ABI and bare methods on the target contract\n   */\n  call: {\n    /**\n     * Invoke this method via an inner transaction call\n     */\n    [key in keyof TContract as key extends 'approvalProgram' | 'clearStateProgram'\n      ? never\n      : TContract[key] extends AnyFunction\n        ? key\n        : never]: ContractProxyMethod<TContract[key]>\n  }\n  /**\n   * Create a bare application call itxn to create the contract.\n   * @param fields Specify values for transaction fields which should override the default values.\n   */\n  bareCreate(fields?: BareCreateApplicationCallFields): ApplicationCallInnerTxn\n}\n\n/**\n * Pre compile the target ARC4 contract and return a proxy object for constructing inner transactions to call an instance of that contract.\n * @param contract An ARC4 contract class\n * @param options Compile contract arguments\n */\nexport function compileArc4<TContract extends Contract>(\n  contract: ConstructorFor<TContract>,\n  options?: CompileContractOptions,\n): ContractProxy<TContract> {\n  throw new NoImplementation()\n}\n\n/**\n * Invokes the target ABI method using a strongly typed fields object.\n * @param method An ABI method function reference.\n * @param fields Specify values for transaction fields.\n */\nexport function abiCall<TArgs extends DeliberateAny[], TReturn>(\n  method: InstanceMethod<Contract, TArgs, TReturn>,\n  fields: TypedApplicationCallFields<TArgs>,\n): TypedApplicationCallResponse<TReturn> {\n  throw new NoImplementation()\n}\n","import { BaseContract } from '../base-contract'\nimport { NoImplementation } from '../internal/errors'\nimport { AnyFunction, DeliberateAny, InstanceMethod } from '../internal/typescript-helpers'\nimport { OnCompleteActionStr } from '../on-complete-action'\nimport { bytes, BytesCompat, uint64 } from '../primitives'\nimport { ARC4Encoded } from './encoded-types'\n\nexport * from './encoded-types'\nexport * from './c2c'\n\n/**\n * The base type for all ARC4 contracts in Algorand TypeScript\n */\nexport class Contract extends BaseContract {\n  /**\n   * Default implementation of an ARC4 approval program, routes transactions to ABI or bare methods based on application\n   * args and on completion actions\n   */\n  override approvalProgram(): boolean {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * Defines conventional routing method names. When used, methods with these names will be implicitly routed to the corresponding\n * application lifecycle event.\n *\n * @remarks This behaviour is independent of a contract explicitly implementing this interface. The interface is provided simply to improve\n * the developer experience of using this feature.\n */\nexport interface ConventionalRouting {\n  /**\n   * The function to invoke when closing out of this application\n   */\n  closeOutOfApplication?: AnyFunction\n  /**\n   * The function to invoke when creating this application\n   */\n  createApplication?: AnyFunction\n  /**\n   * The function to invoke when deleting this application\n   */\n  deleteApplication?: AnyFunction\n  /**\n   * The function to invoke when opting in to this application\n   */\n  optInToApplication?: AnyFunction\n  /**\n   * The function to invoke when updating this application\n   */\n  updateApplication?: AnyFunction\n}\n\n/**\n * The possible options for a method being available on application create\n *\n * allow: This method CAN be called when the application is being created, but it is not required\n * disallow: This method CANNOT be called when the application is being created\n * require: This method CAN ONLY be called when the application is being created\n */\nexport type CreateOptions = 'allow' | 'disallow' | 'require'\n\n/**\n * Type alias for a default argument schema\n * @typeParam TContract The type of the contract containing the method this default argument is for\n */\nexport type DefaultArgument<TContract extends Contract> =\n  | {\n      /**\n       * A compile time constant value to be used as a default\n       */\n      constant: string | boolean | number | bigint\n    }\n  | {\n      /**\n       * Retrieve the default value from a member of this contract. The member can be\n       *\n       * LocalState: The value is retrieved from the calling user's local state before invoking this method\n       * GlobalState: The value is retrieved from the specified global state key before invoking this method\n       * Method: Any readonly abimethod with no arguments can be used as a source\n       */\n      from: keyof TContract\n    }\n/**\n * Configuration options for an abi method\n * @typeParam TContract the type of the contract this method is a part of\n */\nexport type AbiMethodConfig<TContract extends Contract> = {\n  /**\n   * Which on complete action(s) are allowed when invoking this method.\n   * @default 'NoOp'\n   */\n  allowActions?: OnCompleteActionStr | OnCompleteActionStr[]\n  /**\n   * Whether this method should be callable when creating the application.\n   * @default 'disallow'\n   */\n  onCreate?: CreateOptions\n  /**\n   * Does the method only perform read operations (no mutation of chain state)\n   * @default false\n   */\n  readonly?: boolean\n  /**\n   * Override the name used to generate the abi method selector\n   */\n  name?: string\n\n  /**\n   * Specify default arguments that can be populated by clients calling this method.\n   *\n   * A map of parameter names to the default argument source\n   */\n  defaultArguments?: Record<string, DefaultArgument<TContract>>\n}\n\n/**\n * Declares the decorated method as an abimethod that is called when the first transaction arg matches the method selector\n * @param config The config for this abi method\n * @typeParam TContract the type of the contract this method is a part of\n */\nexport function abimethod<TContract extends Contract>(config?: AbiMethodConfig<TContract>) {\n  return function <TArgs extends DeliberateAny[], TReturn>(\n    target: (this: TContract, ...args: TArgs) => TReturn,\n    ctx: ClassMethodDecoratorContext<TContract>,\n  ): (this: TContract, ...args: TArgs) => TReturn {\n    throw new NoImplementation()\n  }\n}\n\n/**\n * Configuration options for a bare method\n */\nexport type BareMethodConfig = {\n  /**\n   * Which on complete action(s) are allowed when invoking this method.\n   * @default 'NoOp'\n   */\n  allowActions?: OnCompleteActionStr | OnCompleteActionStr[]\n  /**\n   * Whether this method should be callable when creating the application.\n   * @default 'disallow'\n   */\n  onCreate?: CreateOptions\n}\n\n/**\n * Declares the decorated method as a baremethod that can only be called with no transaction args\n * @param config The config for this bare method\n * @typeParam TContract the type of the contract this method is a part of\n */\nexport function baremethod<TContract extends Contract>(config?: BareMethodConfig) {\n  return function <TArgs extends DeliberateAny[], TReturn>(\n    target: (this: TContract, ...args: TArgs) => TReturn,\n    ctx: ClassMethodDecoratorContext<TContract>,\n  ): (this: TContract, ...args: TArgs) => TReturn {\n    throw new NoImplementation()\n  }\n}\n/**\n * Returns the ARC4 method selector for a given ARC4 method signature. The method selector is the first\n * 4 bytes of the SHA512/256 hash of the method signature.\n * @param methodSignature An ARC4 contract method reference. (Eg. `MyContract.prototype.myMethod`)\n * @returns The ARC4 method selector. Eg. `02BECE11`\n */\nexport function methodSelector(methodSignature: InstanceMethod<Contract>): bytes\n/**\n * Returns the ARC4 method selector for a given ARC4 method signature. The method selector is the first\n * 4 bytes of the SHA512/256 hash of the method signature.\n * @param methodSignature An ARC4 method signature string (Eg. `hello(string)string`.  Must be a compile time constant)\n * @returns The ARC4 method selector. Eg. `02BECE11`\n */\nexport function methodSelector(methodSignature: string): bytes\nexport function methodSelector(methodSignature: string | InstanceMethod<Contract>): bytes {\n  throw new NoImplementation()\n}\n\n/**\n * Interpret the provided bytes as an ARC4 encoded type with no validation\n * @param bytes An arc4 encoded bytes value\n * @param prefix The prefix (if any), present in the bytes value. This prefix will be validated and removed\n */\nexport function interpretAsArc4<T extends ARC4Encoded>(bytes: BytesCompat, prefix: 'none' | 'log' = 'none'): T {\n  throw new NoImplementation()\n}\n\n/**\n * Decode the provided bytes to a native Algorand TypeScript value\n * @param bytes An arc4 encoded bytes value\n * @param prefix The prefix (if any), present in the bytes value. This prefix will be validated and removed\n */\nexport function decodeArc4<T>(bytes: BytesCompat, prefix: 'none' | 'log' = 'none'): T {\n  throw new NoImplementation()\n}\n\n/**\n * Encode the provided Algorand TypeScript value as ARC4 bytes\n * @param value Any native Algorand TypeScript value with a supported ARC4 encoding\n */\nexport function encodeArc4<const T>(value: T): bytes {\n  throw new NoImplementation()\n}\n\n/**\n * Return the total number of bytes required to store T as ARC4 bytes.\n *\n * T must represent a type with a fixed length encoding scheme.\n * @typeParam T Any native or arc4 type with a fixed encoding size.\n */\nexport function arc4EncodedLength<T>(): uint64 {\n  throw new NoImplementation()\n}\n"],"names":[],"mappings":"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"}